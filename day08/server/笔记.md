## 什么是计算机
- 计算机（computer）俗称电脑，是现代一种用于高速计算的电子计算机器，可以进行数值计算，又可以进行逻辑计算，还具有存储记忆功能。是能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。

## 计算机硬件的组成
- 硬件一般可分为输入、输出、算术逻辑、控制及记忆，其中算术逻辑和控制合称中央处理（CPU）
- 台式机，笔记本，服务器，超级计算机，pad, 智能手机，智能手表，智能手环，智能车机，

## 计算机软件的分类
- 系统软件：为应用软件提供一个平台，应用软件和硬件之间的交互都通过操作系统来完成。如： MS-DOS，Windows系列，MacOS，Linux类，Android，iOS 等
- 应用软件：所有的应用软件都要安装到操作系统上边。如：王者，微信，B站，office，浏览器，vscode，代码的运行环境：JVM node Python 等，cmd（termimal等终端）使用各种语言编写的服务端运行程序, 数据库服务端，等等。

## 网络应用分类
- 1. C/S架构 Client-Server 客户端负责与用户的交互，服务器负责数据的管理。QQ，微信，游戏等各种各样的应用。
- 2. B/S架构 Browser/Server 统一了客户端，客户机上只要安装一个浏览器，所有的交互通过浏览器完成。

## 什么是代码的运行环境（或者说：运行时 runtime）
- 在计算机内部，所有的计算都是由CPU完成的，但是CPU只认识由`0,1`编码成的机器语言，
  我们在编程的时候使用的JavaScript，java，C，Python等编程语言编写的代码，CPU不能直接识别，所以中间要有一层翻译的过程，这个翻译的工作就是由各个语言相对应的运行环境来完成的。

## 什么是高级编程语言 JavaScript TypeScript java PHP Python go ......
   - 语言本质上是一种共同的约定的集合，比如：
   - 树上的一种水果，红红的，圆圆的，甜甜的，有些人约定叫做“苹果”，有些人约定叫做“apple”
   - 当看到一个饥饿的狮子就在我们面前是，我们心里的感觉，有些人约定叫做“恐惧”，有些人约定叫做“fear”
   - 这样一个又一个的约定，就构成了语言，比如汉语，英语。
   - 计算机高级编程语言也是如此
   - 比如JS，约定用`var`声明变量，用`function`声明函数，用`if`表示判断，用`for`表示循环，
   - 用`+ - * / ++ -- += && || typeof instanceof new`表示特定的某种运算，约定函数有作用域，约定对象有原型链等等。
   - JS这个运行环境不仅给我们提供了这些规则，还给我们提供了一些内置好的东西，我们称之为标准库（或内置对象）。
   - 比如: Object Array Boolean Number String Math Date RegExp JSON 这些对象，以及上边的属性和方法。
   - JS语言这个约定就是JS运行环境制定的以上这些一系列规则的集合。我们要想写出能在这个环境里正确执行的程序，就要按照这个规则来编写我们的代码。
   - 以上这些就是js核心的总体概括。其他java，Python任何一门计算机高级语言也大体就是如此。

## 浏览器主要由哪几部分组成
- 浏览器主要由两部分组成:
  1. 浏览器外壳：用户可以在屏幕上看到的界面，如：地址栏，前进后退按钮等。
  2. 浏览器内核：内核可分为**UI的渲染引擎**和**JS的执行引擎**（也可以叫做：JS的运行环境）
    - **UI渲染引擎**负责解析HTML，css，图片，音视频等把最终结果渲染到显示屏上。
    - **JS执行引擎**负责解析并运行js代码。浏览器还给js引擎提供了BOM和DOM。常见的js引擎如下：
      1. Chrome-----V8
      2. FireFox----SpiderMonkey
      3. Safari-----JavaScriptCore
      4. Edge/IE----Chakra
      5. Node-------V8

 - BOM:  history location Storage接口 Navigator Screen Image XMLHttpRequest Canvas 等
 - DOM:  Document  Element  Event  NodeList 等

## Node由哪几部分组成
- Node 主要有两部分组成
  1. 一些核心模块，如：fs,http,os等，可以用代码直接和操作系统交互。
  2. V8引擎，负责解析并且运行js代码。

  node官网： http://nodejs.cn/

## 服务器
- 服务器
- 1. 物理服务器：配置比较高的电脑
- 2. 软件服务器：程序员用计算机语言编写的服务器程序，java，PHP，node，Python等。

- 服务器一般由以下构成
- 1. web服务器（也叫HTTP服务器，也叫web容器）：Apache Nginx等
- 2. 应用服务器：Tomcat服务器，PHP服务器等
- node服务器，不需要web容器，用node时，实现的是web服务器和应用服务器所有的内容。

## 运行node的两种方式
  1. 终端中运行 `node` 命令，直接开启Node交互环境
  2. 使用node命令运行js文件：`node a.js`

## JS的模块化规范 
- commonjs:一个文件就是一个模块 导出：module.exports，导入：require，运行在nodejs服务端，
    特点：同步加载同步执行

- AMD:定义一个模块 define()，导出：module.exports，导入：require，比较通用的库是：require.js 
    特点：异步加载，require加载时执行

- CMD:定义一个模块 define()，导出：module.exports，导入：require，比较通用的库是：sea.js 
    特点：异步加载 require加载时不执行，懒执行

- UMD: AMD和CMD的结合体。

- ESModule: 导出：export， 导入：import， 
    特点： import from 是静态加载、import()函数是动态加载

- 相对目录：./   （ .代表当前目录，  ..代表上一级目录）
- 绝对目录：/    （ / 代表根目录）

- commonjs中引入包require()：  （在node中都是js模块，所以引入模块是`.js`可以省略）
  1. 有 "./"
     在当前目录找
  2. 没有 "./"
     1. 先从系统模块找
     2. 再从node_modules找

- node中，模块大体分为三种：
  1. 核心模块（也叫内置模块, 如： http fs url os ...）
  2. 文件模块（已经发布到npm上的模块，可以通过npm install下载的模块， 如：mongoose ...）
  3. 自己写的模块

## npm: node的包管理工具 
- npm --help
- npm init   // 初始化项目 生成package.json文件
- npm login/logout  // 登录  退出登录
- npm whoami
- npm publish  // 发布
- npm config  get/set registry     `npm config set registry http://registry.npm.taobao.org/
- npm install  // 可简写为 i
- npm install cnpm -g
- npm install nodemon -g

## URL ： 域名  IP地址   端口

## http
- http.creatServer((req, res) => {})   创建一个简单的http服务
- 1. req.httpVersion
- 2. req.url
- 3. req.method
- 4. req.headers

- 1. res.setHeader('Content-Type', 'text/html'); 
- 1. res.write('aaa');
- 2. res.end();

- get 参数解析
- 1. native
- 2. querystring
- 3. url

- post 参数解析
- 1. res.on('data' (data)=> {})
- 2. res.on('end' ()=> {})
- 3. querystring

- 注册登录 案例

## 客户端和服务端的概念
- 客户端：发起请求的一端（专门获取数据的客户），如：浏览器，postman，curl命令行，数据库命令行客户端，数据库可视化工具客户端 等。
- 服务端：接收请求的一端（专门提供数据服务的服务员），如：node服务器，java服务器，PHP服务器，Python服务器，数据库服务器 等。

## ajax 
```js
    //1.  创建 Ajax 对象
    var xhr = new XMLHttpRequest();
    //2.  告诉 Ajax 请求地址以及请求方式
    xhr.open('get', 'http://www.example.com');
    //3.  发送请求
    xhr.send();
    //4.  获取服务器端给与客户端的响应数据
    xhr.onload = function () {
        console.log(xhr.responseText);
    }

    // 服务端配置CROS 配置允许跨域请求的请求头
    res.setHeader('Access-Control-Allow-Origin', '*')              // 允许所有域名跨域访问
    res.setHeader('Access-Control-Allow-Methods', 'POST')          // 允许post方法的请求跨域访问
    res.setHeader('Access-Control-Allow-Headers', 'content-type')  // 允许带有content-type头的请求跨域访问
    response.setHeader("Access-Control-Allow-Credentials", "true") // 允许跨域访问时携带cookie
```
## 跨域：
- 从浏览器发出的不遵循同源策略的ajax请求，被称为跨域请求。另外：localStorage sessionStorage cookie 默认也要遵循同源策略。
- **同源策略**：发出请求的域，和接收请求的域，要遵循：**协议名、域名、端口号全部相同**。
- 大部分解决跨域问题的方法本质上都是在绕开浏览器同源策略的限制。比如：
    - 1. **jsonp**： 通过一个script标签发送一个js文件的静态资源请求，不再发送ajax请求，所有也就不会受到同源策略的限制。
    - 2. **代理**：通过一个和请求域相同地址的服务器做中间代理，用这个中间服务器去请求真正的服务器，然后把数据给到浏览器。
    - 3. **CORS跨站资源共享  Cross-origin resource sharing**：当浏览器检测到即将要发送跨域请求时，会先发一个option请求（也叫预检请求），这个请求的目的是带着请求发出域的地址去询问服务器，是否允许，服务器根据这个地址判断，如果允许，会在这个option请求的响应头里添加跨域头，否则不添加。浏览器收到option相应后，会检查响应头中是否有跨域头，如果有就继续发送真正的请求，如果没有就会报错。

## express 基础
    官网: https://www.expressjs.com.cn/
```js
    app = express();
    app.get()
    app.post()
    app.use()

    res.cookie(name, value [, options])
    res.clearCookie(name [, options])

    res.write()
    res.end()
    res.send() // 可以是非字符串或buffer  非侵入  增强版

    res.render('index', function (err, html) {  res.send(html)})
    res.render('index', { name: 'Tobi' }, function (err, html) {  /* // ...  */ })
    res.redirect(302, 'http://example.com') // 重定向


    // 动态路由
    app.get("/article/:id", (req, res) => {
        var id = req.params["id"]    //获取动态路由
        res.send("动态路由" + id)
    })
```

- 路由 中间件  应用级中间件 路由级中间件 错误处理中间件 内置中间件 第三方中间件
- `app.get('/', function (req, res, next) { })`
- `app.post('/', function (req, res, next) { })`    
- `app.use('/', function (req, res, next) { })`
- `app.use(function (req, res, next) { })`

- 数据解析
- get:  req.query
- post: req.body  需要body-parser中间件 
- `app.use(bodyParser.urlencoded({ extended: false }));`  
- `app.use(bodyParser.json());`
- 中间件
- 链式操作

- multer 解析上传文件
```js
    const multer = require('multer'); // 解析post文件 enctype="multipart/form-data"
    app.use(multer({ dest: './www/upload' }).any()); // 解析文件上传    参数：文件存放路径
    console.log(req.files);
```

- 官网：https://www.expressjs.com.cn/starter/hello-world.html


## cookie session
- http 无状态  cookie session是让服务器记录客户状态的机制
- cookie：在浏览器保存一些数据，每次请求都会带过来   特点：不安全、有限(4K)
- session：基于cookie实现 真正的数据保存在服务端    特点：相对安全、无限  （session劫持）

- 当浏览器访问服务器并发送第一次请求时，服务器端会创建一个 session 对象，生成一 个类似于 key,value 的键值对， 然后将 sessionId返回到浏览器(客户)端，浏览器下次 再访问时，携带 sessionId，找到对应的 session对象。

- npm install cookie-parser
- `app.use(cookieParser()); // 这一步执行了之后才能有req.coolies, req.signedCookie, 如果coolie签名，需要传入key`
- `res.cookie('name', user, { path: '/', maxAge: 10 * 1000, signed: true })  // 设置cookie 10S`
- 设置cookie：res.cookie()
- 获取cookie: req.coolies, req.signedCookie   // 根据signed: true/false来区分。
- `cookie：未签名：111111，   已签名：s%3A111111.OJZoc9fmPJDqbNRN7U7SI%2BVLVIT%2BoYmUqb6gHr6KuSc`
- `session：eyJpc0xvZ2luIjp0cnVlfQ==`

- npm install cookie-session
```js
    const cookieParser = require('cookie-parser');
    const cookieSession = require('cookie-session');

    app.use(cookieParser());
    app.use(cookieSession({ name: 'sess', keys: ['aaa', 'bbb'], maxAge: 2 * 3600 * 1000 }));

    // res.cookie('name', user, { path: '/', maxAge: 10 * 1000, signed: true }) // 设置cookie 10S
    req.session.isLogin = true;
    req.session.username = 'zs';

    if (req.session.isLogin) { /* 已登录 */ }
```


## ejs
- `ejs.renderFile('./views/1.ejs', { name: 'blue' }, function (err, data) {console.log(data);});`
- `<%= name %>` 输出（HTML转义）
- `<%- name %>` 输出（HTML非转义）
```js
    <% for(var i=0;i<json.arr.length;i++){ %> // js代码写在 <%   %>
        <div>用户名：<%=json.arr[i].user%> 密码：<%=json.arr[i].pass%></div>
    <% } %>
``` 

- `<% include('../a.txt') %>`  引入文件 不能使用变量

- express + ejs
- express 内置了ejs 所以无需安装
```js
    // 配置模板引擎
    app.set('views', path.join(__dirname, 'views')); // 默认地址 可以省略
    app.set("view engine", "ejs");
    res.render("index.ejs", { title: title })
``` 

- 官网: https://ejs.bootcss.com/#features

 ## mongo 基础
    官网：https://www.mongodb.com/
- 默认安装目录： `C:\Program Files\MongoDB\Server\4.4\bin`
- 安装后会自动配置环境变量，如果没有配置，就自己手动配置一下。
- 客户端：`mongo.exe`  服务端：`mongod.exe`
- 4.0+安装后默认会自动启动服务端 `mongod.exe`，启动默认配置文件：`mongod.cfg`，默认配置了数据库存放地址，log地址，启动端口。
- 在命令行执行：mongo （或者在安装目录双击：mongo.exe）  可以连接Mongo服务端。（通过命令行这个客户端连接数据）
- shell命令 mongo,  node中的mongoose包，可视化工具都是mongo的客户端。 mongod.exe是mongo的服务端。

- 常用命令：
  1. show dbs                  查看数据库
  2. use `dbName`              使用（创建）数据库
  3. show collections          查看当前数据库的集合collections（表）

  - 数据的增删改查都是针对collections的， 命令分别为：insert remove update find 四个函数 
  4. db.`user`.insert({name: "zhangsan", age: 20});            插入数据

  5. db.`user`.remove({name: 'zs'})                            删除

  6. db.`user`.update({name: 'zz'}, {$set: {age: 33}})         更新
  6. db.`user`.update({name: 'zz'}, {name: 'zznew' age: 33})   更新

  7. db.`user`.find()                                  查找所有数据
  7. db.`user`.find({age: 20}})                        查找 age=20  的数据   greater then     less then    equal
  7. db.`user`.find({age: {$gt: 20}})                  查找 age>20  的数据
  7. db.`user`.find({age: {$gte: 20}})                 查找 age>=20 的数据
  7. db.`user`.find({age: {$lt: 20}})                  查找 age<20  的数据
  7. db.`user`.find({age: {$lte: 20}})                 查找 age<=20 的数据
  7. db.`user`.find({age: {$gt: 18, $lt:25}})          查找 age>18 并且 age<25 的数据（多条件查询）
  7. db.`user`.find({$or: [{age: 20}, {age: 22}]})     查找 age=20 或者 age=22 的数据（多条件查询）
  7. db.`user`.find({name: /san/})                     查找 name 中包含san 的数据  模糊查询（性能不是太好）
  7. db.`user`.find({age: {$lte: 20}}).sort({age:1})   查找 age<=20 的数据 按age升序排序， 升序 1  降序 0
  7. db.`user`.find().limit(10).skip(20)               查找 跳过20条数据后的10条数据
  7. db.`user`.find().count()                          查找 到数据的数据个数

  8. db.collectionName.drop()  删除指定集合collections（表）
  9. db.dropDatabase()         删除当前数据库


## mongo数据库组成
- BSOM => json   数据库 db 》 最外层集合 collection（表）  》  文档 document

- mongoose 1.固定存放的格式schema  2.集合model  3.操作数据document

- Mongoose 的一切始于 Schema。每个 schema 都会映射到一个 MongoDB collection ，并定义这个collection里的文档的构成。
- Models 是从 Schema 编译来的构造函数。
- Documents 是 model 的实例


```js
    // 1.引入mongoose
    let mongoose = require('mongoose');

    // 2.连接mongodb服务端
    mongoose.connect('mongodb://127.0.0.1:27017/mongooseDemo', { useNewUrlParser: true, useUnifiedTopology: true }, function (err) {
        if (err) return console.log(err)
        console.log('数据库连接成功')
    });

    // 3.创建schema schema是用来约束collection里边的数据的。
    let NewsSchema = mongoose.Schema({
        name: String,
        age: Number,
        gender: {
            type: String,
            default: '无',
            trim: true // 修饰符--去掉空格
        }
    })

    // 4.通过schema创建模型，参数1：model名对应，参数2：所使用的schema，参数3：集合名称，省略的话默认是小写model名称+s
    var User = mongoose.model('User', NewsSchema, 'user');

    // 增删改查都是通过模型来完成的 User
    // 5.增加数据
    let user = new User({ name: 'wangwu', age: 30, gender: true });
    user.save(function (err, data) {
        if (err) return console.log(err)
    });

    // 5.添加的另一种方式
    User.create({ name: 'wangwu', age: 30, gender: true }, function(err, data) {
        if (err) return console.log(err)
    })

    // 6.查询数据 find
    User.find({}, function (err, data) {
        if (err) return console.log(err)
    });

    // 7.更新数据 update  updateOne
    User.update({ name: "wangwu" }, { name: 'wangwu姐姐', gender: '女' }, function (err, data) {
        if (err) return console.log(err);
    })

    // 8.删除数据 delete deleteOne
    User.deleteOne({ name: 'wangwu' }, function (err, data) {
        if (err) return console.log(err);
    })

    // MyModel.find() 这样的函数会返回一个Query实例。
    MyModel.count() // collection中的document个数
    MyModel.find({ name: 'abc', age: { $gte: 18 }}, function (err, docs) {}); // name='abc' age>=18
    MyModel.find({ name: /abc/i }, 'name friends', function (err, docs) { }); // name不区分大小写， 显示name friends字段
    MyModel.find({}, '-_id -cTime', {skip: 5, limit: 3, sort: {age: 1}}, function (err, docs) {});  // 查所有，不显示_id cTime字段，age正序， 跳过5条，要3条，
    MyModel.find().sort({ _id: -1 }).limit(3).skip(5).exec(function (err, docs) { res.render('list.ejs', { docs }) })
    MyModel.findById(id, 'name length', function (err, adventure) {}); // 用ID查找  findOne({ _id: id })
    MyModel.find({ $or: [{ username: { $regex: /abc/g } }, { age: { $regex: /abc/g } }] }, function (err, docs) { }) // 查找username 或者age中可以匹配到 /abc/g 的数据

    MyModel.update({ name: 'Tobi' }, { password: '111111' }, { multi: true }, function (err, raw) {} // 全部更新
    MyModel.updateOne({ name: 'Tobi' }, { password: '111111' }, function (err, raw) {} // 更新一个
    Info.update({ username: 'bb' }, { $set: { password: '333333' } }, (err, doc) => { })

    MyModel.remove({ name: 'abc' }, function (err) {});  // 删除
```































